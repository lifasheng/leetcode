
1. http://www.geeksforgeeks.org/dynamic-programming-set-18-partition-problem/
   将一个整数数组分成两个子数组A和B，A和B的大小可以不相等，但是这两个子数组各自元素的和相等。
   sum(A) == sum(B)
2. 设一个整数数组的大小为偶数，将该数组分成相同大小的两个子数组，让他们的和最接近。
   A.size() == B.size()
   sum(A) == sum(B)
 

一开始看到这个题，没有什么思路，静下心，别着急。

首先想到递归 + 神搜

设原始整数数组是s，A表示A子数组的和，B表示B子数组的和，k表示当前处理s的下标
f(s, A, B, k)
{
    if(k == s.size()) {
        return A == B;
    }
    b1 = f(s, A+s[k], B, k+1);
    if (b1) return b1;
    b2 = f(s, A, B+s[k], k+1);
    if (b2) return b2;
    return false;
}


进一步，这其实就是2^N的递归。
和二进制表示没什么区别。

对于这两个问题，可以利用二进制表示来解决。
问题1只需遍历所有二进制表示，就可以。


对于问题2，不用遍历所有的二进制表示，而只是其中一部分。
比如s大小为4
则：
0000
0001
0010
0011 -> 3
0100
0101 -> 5
0110 -> 6
0111
1000
1001 -> 9 = 8+1
1010 -> 10 = 8+2
1011
1100 -> 12 = 8+4
1101
1110
1111

因为我们是要分成两个相同大小的子数组，所以只有上面这两个表示是可能的。
而0开头的3，5，6其实本质删和1开头的9，10，12是一样的，只是翻转0和1而已。

而以1开头的，我们比较好构造出来。
位数为4，所以只有2个1
开头为1，则另一个1只能在3个位置，分别是1<<0, 1<<1, 1<<2

当然对于6位，8位的要仔细考虑一下如何构造。

一旦构造出这几个数，则只需遍历这几个数，判断他们的和是否相等。
比如1001，假设1表示将该位置的数加入A，0表示加入B。



