class Solution {
public:
#define M1
#ifdef M1
// 实现STL中的next_permutation, 时间复杂度 O(n!),空间复杂度 O(1)
    template <typename BirectionalIterator>
    bool my_next_permutation(BirectionalIterator first, BirectionalIterator last) {
        if (first == last) return false;
        
        typedef reverse_iterator<BirectionalIterator> ReverseIterator;
        
        ReverseIterator rfirst(last), rlast(first);
        
        // step1
        ReverseIterator pivot = next(rfirst);
        while(pivot != rlast && *pivot >= *(prev(pivot))) {
            ++pivot;
        }
        
        if (pivot == rlast) {
            reverse(first, last);
            return false;
        }
        
        // step2
        ReverseIterator change = find_if(rfirst, pivot, bind1st(less<int>(), *pivot));
        
        // step3
        swap(*pivot, *change);
        
        // step4
        reverse(rfirst, pivot);
        
        return true;
    }
    vector<vector<int> > permute(vector<int> &num) {
        vector<vector<int> > result;
        sort(num.begin(), num.end()); // 这种方法要求排序
        
        do {
            result.push_back(num);
        }
        while(my_next_permutation(num.begin(), num.end()));
        
        return result;
    }
#endif
#ifdef M2 
/*
迭代版， 思路类似于subsets，递归版也很容易。
比如[1 2 3]
假设[1 2]的全排列已经得到，即[1 2] [2 1];
对于这两个数组，需要把3插入到每个数组的相应位置。
设数组的大小为n，则有n+1个位置可以插入。
插入后得到[3 1 2] [1 3 2] [1 2 3]; [3 2 1][2 3 1][2 1 3]
注意和subsets一个不同的地方是：这里不能把中间过程放到最终结果中!!!
这种方法的空间复杂度不好，需要很大的辅助空间，但是思路很清晰。
*/
    vector<vector<int> > permute(vector<int> &num) {
        vector<vector<int> > result(1); // 一开始有个空数组[]
        
        for(int i=0; i<num.size(); ++i) {
            vector<vector<int> > temp;
            int size = result.size();
            for(int j=0; j<size; ++j) {
                insert_num(result[j], num[i], temp);
            }
            result = temp;
        }
        
        return result;
    }
    
    // 将一个数插入到数组中，设数组大小为n，则共有n+1个插入位置，得到n+1个新数组。
    void insert_num(vector<int> &v, int val, vector<vector<int> > &result) {
        int n = v.size();
        for(int i=0; i<=n; ++i) { // n+1个插位置
            vector<int> v2(n+1); // 新数组
            
            for(int j=0; j<i; ++j) { // 前i-1个位置，两个数组的下标相同
                v2[j] = v[j];
            }
            v2[i] = val;             //将数插入到第i个位置
            for(int j=i+1; j<=n; ++j) { //后n-i个数，注意下标
                v2[j] = v[j-1];
            }
            
            result.push_back(v2);
        }
    }

    // 迭代版， 更紧凑。 
    vector<vector<int> > permute(vector<int> &num) {
        sort(num.begin(), num.end());
        
        vector<vector<int> > result(1);
        for(int i=0; i<num.size(); ++i) {
            const int n = result.size();
            vector<vector<int> > temp; // 保存中间结果
            for(int j=0; j<n; ++j) {
                for(int k=0; k<=result[j].size(); ++k) {
                    vector<int> v = result[j];
                    v.insert(next(v.begin(),k), num[i]);
                    temp.push_back(v);
                }
            }
            result = temp;
        }
        return result;
    }
#endif
#ifdef M3
/*
http://yucoding.blogspot.com/2013/04/leetcode-question-69-permutations.html
The idea of this classic problem is to use backtracking.
We want to get permutations, which is mainly about swap values in the list.
Consider:
a --> a
ab --> ab, ba
abc --> abc, acb, bac, bca, cab, cba.
...
where for the length of n, the permutations can be generated by
(1) Swap the 1st element with all the elements, including itself.
(2) Then the 1st element is fixed, go to the next element.
(3) Until the last element is fixed. Output.
The key point is to make the big problem into smaller problem, here is how to convert the length n permutation into length n-1 permutation problem.
这里关键点是如何有效地缩小问题的规模，从而实现高效的递归。
上面M2的递归思路很容易理解，但是效率不好，因为涉及到大量的数据拷贝，还用到了不小的辅助空间。
同样是将问题规模缩小，本方法就比较高效，而且O(1) space。
*/
    vector<vector<int> > permute(vector<int> &num) {
         vector<vector<int> > result;
         permute(num, 0, result);
         return result;
    }
    
    void permute(vector<int> &num, int start, vector<vector<int> > &result) {
        if(start == num.size()-1) { // 到最后一个元素时，没必要再进行下去了。
            result.push_back(num);
            return;
        }
        
        for(int i = start; i < num.size(); ++i) {
            swap(num[i], num[start]);
            permute(num, start+1, result);
            swap(num[i], num[start]);
        }
    }
#endif
#ifdef M4
// 递归，用标志位记录已使用数字。时间复杂度 O(n!),空间复杂度 O(n)
// 用visited数组来辅助，比用find来查找，在时间上效率高。
    vector<vector<int> > permute(vector<int> &num) {
        vector<vector<int> > result;
        vector<bool> visited(num.size(), false);
        vector<int> path;
        permute(num, 0, visited, path, result);
        return result;
    }
    
    void permute(vector<int> &num, int step, vector<bool> &visited, vector<int> &path, vector<vector<int> > &result) {
        if (step == num.size()) {
            result.push_back(path);
            return;
        }
        
        for(int i=0; i<num.size(); ++i) {
            if (!visited[i]) {
                visited[i] = true;
                path.push_back(num[i]);
                permute(num, step+1, visited, path, result);
                path.pop_back();
                visited[i] = false;
            }
        }
    }
#endif
};
